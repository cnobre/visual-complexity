---
title: "processUpset"
output: html_document
---

## Setup

```{r setup}
library(tidyverse)
library(ggridges)
library(pwr) 
library(grid)
library(gtable)

library(boot)
library(bootES)


library(ggbeeswarm)

library(tidybayes)
library(cowplot)
library(broom)

theme_set(theme_tidybayes() + panel_border() + background_grid())


#df <- read.csv("../results/pilot/CSV/TidyR.csv")
df <- read.csv("results/TidyR_upset.csv")

# dfp <- read.csv("../results/study/CSV/participantInfoTidyR.csv")
```



## Data Cleaning / Types

```{r}

df_acc <- df %>% 
  filter(measure=="accuracy") 


df_acc$value = as.numeric( as.character(df_acc$value ))


```



```{r}

df %>% 
  filter(measure=="accuracy") %>% 
  mutate( value = as.numeric( as.character(value)) ) %>% 
  ggplot( aes(x=condition, y=value) ) +
    geom_jitter( alpha = 0.2, width=0.1, height=0.3 ) + 
    stat_summary(fun.data = "mean_cl_boot", colour = "red", size = 0.5, position = position_nudge(x=0.25, y=0), alpha=0.5) +
  coord_flip() +
    facet_grid(task ~ . )

df %>% 
  filter(measure=="selection" & task=='K1') %>% 
 ggplot( aes(x=value)) + 
  geom_histogram(stat="count")+
    facet_grid(condition ~ . )

df %>% 
  filter(measure=="selection" & task=='K2') %>% 
 ggplot( aes(x=value)) + 
  geom_histogram(stat="count")+
    facet_grid(condition ~ . )

df %>% 
  filter(measure=="selection" & task=='K3') %>% 
 ggplot( aes(x=value)) + 
  geom_histogram(stat="count")+
    facet_grid(condition ~ . )

df %>% 
  filter(measure=="selection" & task=='K4') %>% 
 ggplot( aes(x=value)) + 
  geom_histogram(stat="count")+
    facet_grid(condition ~ . )

df %>% 
  filter(measure=="selection" & task=='K5') %>% 
 ggplot( aes(x=value)) + 
  geom_histogram(stat="count")+
    facet_grid(condition ~ . )




```


## Power Analysis

```{r}

powerAnalysisGraph <- function(m1, m2, stdev, iterNum=15){
  # stdev <- sd_duration.median
  # m1 <- mean(search$duration.median)
  # m2 <- mean(nonsearch$duration.median)
  # # m1 <- mean(foresight$duration.median)
  # # m2 <- mean(nonsearch$duration.median)
  
  iteration <- 15
  
  difference <- 0
  effectSize <- 0
  numParticipants <- 0
  
  for(step in 1:iteration)
  {
    difference[step] <- abs(m1 - m2) * (0.9 ^ (step-1))
    effectSize[step] <- difference[step] / stdev
    numParticipants[step] <- pwr.t.test( 
      d=effectSize[step], 
      sig.level=.05, 
      power=0.8, 
      type="two.sample", 
      alternative="greater" 
    )$n * 1.15 * 2
  }
  
  #dual axis code online: https://rpubs.com/kohske/dual_axis_in_ggplot2
  grid.newpage()
  
  pw <- data.frame(difference=difference, numParticipants=numParticipants, effectSize=effectSize)
  p1 <- ggplot(pw,aes(x=difference)) + geom_line(aes(y = numParticipants)) +
    scale_y_continuous(breaks = pretty(pw$numParticipants, n = 10))
  p2<- ggplot(pw,aes(x=difference)) + geom_line(aes(y = effectSize)) +
    theme(panel.background = element_rect(fill = NA))+
    scale_y_continuous(breaks = pretty(pw$effectSize, n = 10))
  p2
  
  # extract gtable
  g1 <- ggplot_gtable(ggplot_build(p1))
  g2 <- ggplot_gtable(ggplot_build(p2))
  
  # overlap the panel of 2nd plot on that of 1st plot
  pp <- c(subset(g1$layout, name == "panel", se = t:r))
  g <- gtable_add_grob(g1, g2$grobs[[which(g2$layout$name == "panel")]], pp$t, pp$l, pp$b, pp$l)
  
  # axis tweaks
  ia <- which(g2$layout$name == "axis-l")
  ga <- g2$grobs[[ia]]
  ax <- ga$children[[2]]
  ax$widths <- rev(ax$widths)
  ax$grobs <- rev(ax$grobs)
  ax$grobs[[1]]$x <- ax$grobs[[1]]$x - unit(1, "npc") + unit(0.15, "cm")
  g <- gtable_add_cols(g, g2$widths[g2$layout[ia, ]$l], length(g$widths) - 1)
  g <- gtable_add_grob(g, ax, pp$t, length(g$widths) - 1, pp$b)
  
  # draw it
  grid.draw(g)
}

```




```{r}


# Knowledge
sd_knowledge = df_acc %>% 
  filter(task == "K1") %>% 
  summarise(
    stdev = sd(value)
  )

m_static_knowledge  = df_acc %>% 
  filter(task == "K1" & condition == "static") %>% 
  summarise(
    mean = mean(value)
  )

m_animated_knowledge = df_acc %>% 
  filter(task == "K1" & condition == "animated") %>% 
  summarise(
    mean = mean(value)
  )



```



then, we apply the power analysis to the numbers calculated above




```{r}
# Knowledge Question
powerAnalysisGraph(m_static_knowledge[,1], m_animated_knowledge[,1], sd_knowledge[,1])

```
